
# 什么是死锁？如何避免死锁

所谓死锁就是一个进程集合中的多个进程因为竞争资源，而造成的互相等待现象。很显然，如果没有外力的作用，
那么死锁涉及到的各个进程都将永远处于封锁状态。

产生死锁的原因主要是：
（1） 因为系统资源不足。
（2） 进程运行推进的顺序不合适。
（3） 资源分配不当等。

死锁的必要条件：

互斥条件（Mutual exclusion）：资源不能被共享，只能由一个进程使用。

请求与保持条件（Hold and wait）：已经得到资源的进程可以再次申请新的资源。

非剥夺条件（No pre-emption）：已经分配的资源不能从相应的进程中被强制地剥夺。

循环等待条件（Circular wait）：系统中若干进程组成环路，改环路中每个进程都在等待相邻进程正占用的资源。



这四个条件是死锁的必要条件，只要系统发生死锁，这些条件必然成立，而只要上述条件之一不满足，就不会发生死锁。

  前面介绍了死锁发生时的四个必要条件，只要破坏这四个必要条件中的任意一个条件，死锁就不会发生。
  这就为我们解决死锁问题提供了可能。一般地，解决死锁的方法分为死锁的预防，避免，检测与恢复三种，
  当然还一种是忽略该问题，例如鸵鸟算法，该算法可以应用在极少发生死锁的情况下。
  
 
 
 ## 死锁的预防  
 
  
 
   死锁的预防是保证系统不进入死锁状态的一种策略。它的基本思想是要求进程申请资源时遵循某种协议，
   从而打破产生死锁的四个必要条件中的一个或几个，保证系统不会进入死锁状态。
 
  
 
 〈1〉破坏互斥条件。即允许进程同时访问某些资源。但是，有的资源是不允许被同时访问的，像打印机等等，
 这是由资源本身的属性所决定的。所以，这种办法并无实用价值。
 
  
 
 〈2〉破坏不可剥夺条件。即允许进程强行从占有者那里夺取某些资源。就是说，当一个进程已占有了某些资源，
 它又申请新的资源，但不能立即被满足时，它必须释放所占有的全部资源，以后再重新申请。它所释放的资源可以分配给其它进程。
 这就相当于该进程占有的资源被隐蔽地强占了。这种预防死锁的方法实现起来困难，会降低系统性能。    
 
 
 〈3〉破坏请求与保持条件。可以实行资源预先分配策略。即进程在运行前一次性地向系统申请它所需要的全部资源。
 如果某个进程所需的全部资源得不到满足，则不分配任何资源，此进程暂不运行。只有当系统能够满足当前进程的全部资源需求时，
 才一次性地将所申请的资源全部分配给该进程。由于运行的进程已占有了它所需的全部资源，所以不会发生占有资源又申请资源的现象，
 因此不会发生死锁。但是，这种策略也有如下缺点：
 
  
 
 （1）在许多情况下，一个进程在执行之前不可能知道它所需要的全部资源。这是由于进程在执行时是动态的，不可预测的；
 
  
 （2）资源利用率低。无论所分资源何时用到，一个进程只有在占有所需的全部资源后才能执行。
 即使有些资源最后才被该进程用到一次，但该进程在生存期间却一直占有它们，造成长期占着不用的状况。这显然是一种极大的资源浪费；
 
 
 （3）降低了进程的并发性。因为资源有限，又加上存在浪费，能分配到所需全部资源的进程个数就必然少了。    
 

< 4 >破坏循环等待条件，实行资源有序分配策略。采用这种策略，即把资源事先分类编号，按号分配，使进程在申请，
占用资源时不会形成环路。所有进程对资源的请求必须严格按资源序号递增的顺序提出。
进程占用了小号资源，才能申请大号资源，就不会产生环路，从而预防了死锁。这种策略与前面的策略相比，
资源的利用率和系统吞吐量都有很大提高，但是也存在以下缺点：

（1）限制了进程对资源的请求，同时给系统中所有资源合理编号也是件困难事，并增加了系统开销；

（2）为了遵循按编号申请的次序，暂不使用的资源也需要提前申请，从而增加了进程对资源的占用时间。

## 死锁的避免  

上面我们讲到的死锁预防是排除死锁的静态策略，它使产生死锁的四个必要条件不能同时具备，
从而对进程申请资源的活动加以限制，以保证死锁不会发生。下面我们介绍排除死锁的动态策略--死锁的避免，
它不限制进程有关申请资源的命令，而是对进程所发出的每一个申请资源命令加以动态地检查，
并根据检查结果决定是否进行资源分配。就是说，在资源分配过程中若预测有发生死锁的可能性，则加以避免。
这种方法的关键是确定资源分配的安全性。

 1.安全序列
 
 
我们首先引入安全序列的定义：所谓系统是安全的，是指系统中的所有进程能够按照某一种次序分配资源，
并且依次地运行完毕，这种进程序列{P1，P2，...，Pn}就是安全序列。如果存在这样一个安全序列，则系统是安全的；
如果系统不存在这样一个安全序列，则系统是不安全的。

安全序列{P1，P2，...，Pn}是这样组成的：若对于每一个进程Pi，
它需要的附加资源可以被系统中当前可用资源加上所有进程Pj当前占有资源之和所满足，则{P1，P2，...，Pn}为一个安全序列，
这时系统处于安全状态，不会进入死锁状态。 　

虽然存在安全序列时一定不会有死锁发生，但是系统进入不安全状态（四个死锁的必要条件同时发生）也未必会产生死锁。
当然，产生死锁后，系统一定处于不安全状态。 


 2.银行家算法

这是一个著名的避免死锁的算法，是由Dijstra首先提出来并加以解决的。　

[背景知识] 

一个银行家如何将一定数目的资金安全地借给若干个客户，使这些客户既能借到钱完成要干的事，
同时银行家又能收回全部资金而不至于破产，这就是银行家问题。
这个问题同操作系统中资源分配问题十分相似：银行家就像一个操作系统，客户就像运行的进程，银行家的资金就是系统的资源。

   [问题的描述]
 
一个银行家拥有一定数量的资金，有若干个客户要贷款。每个客户须在一开始就声明他所需贷款的总额。
若该客户贷款总额不超过银行家的资金总数，银行家可以接收客户的要求。
客户贷款是以每次一个资金单位（如1万RMB等）的方式进行的，客户在借满所需的全部单位款额之前可能会等待，
但银行家须保证这种等待是有限的，可完成的。


银行家算法允许死锁必要条件中的互斥条件，占有且申请条件，不可抢占条件的存在，这样，
它与预防死锁的几种方法相比较，限制条件少了，资源利用程度提高了。


 
 这是该算法的优点。其缺点是：
 
 
〈1〉这个算法要求客户数保持固定不变，这在多道程序系统中是难以做到的。   

〈2〉这个算法保证所有客户在有限的时间内得到满足，但实时客户要求快速响应，所以要考虑这个因素。  

〈3〉由于要寻找一个安全序列，实际上增加了系统的开销。

 
## 死锁的检测与恢复  

一般来说，由于操作系统有并发，共享以及随机性等特点，通过预防和避免的手段达到排除死锁的目的是很困难的。
这需要较大的系统开销，而且不能充分利用资源。为此，一种简便的方法是系统为进程分配资源时，不采取任何限制性措施，
但是提供了检测和解脱死锁的手段：能发现死锁并从死锁状态中恢复出来。
因此，在实际的操作系统中往往采用死锁的检测与恢复方法来排除死锁。常利用资源分配图、进程等待图来协助这种检测。

死锁检测与恢复是指系统设有专门的机构，当死锁发生时，该机构能够检测到死锁发生的位置和原因，
并能通过外力破坏死锁发生的必要条件，从而使得并发进程从死锁状态中恢复出来。
一旦在死锁检测时发现了死锁，就要消除死锁，使系统从死锁状态中恢复过来。  

 （1）最简单，最常用的方法就是进行系统的重新启动，不过这种方法代价很大，
 它意味着在这之前所有的进程已经完成的计算工作都将付之东流，包括参与死锁的那些进程，以及未参与死锁的进程。

 （2）撤消进程，剥夺资源。终止参与死锁的进程，收回它们占有的资源，从而解除死锁。
 这时又分两种情况：一次性撤消参与死锁的全部进程，剥夺全部资源；或者逐步撤消参与死锁的进程，逐步收回死锁进程占有的资源。
 一般来说，选择逐步撤消的进程时要按照一定的原则进行，目的是撤消那些代价最小的进程，比如按进程的优先级确定进程的代价；
 考虑进程运行时的代价和与此进程相关的外部作业的代价等因素。 

此外，还有进程回退策略，即让参与死锁的进程回退到没有发生死锁前某一点处，并由此点处继续执行，以求再次执行时不再发生死锁。
虽然这是个较理想的办法，但是操作起来系统开销极大，要有堆栈这样的机构记录进程的每一步变化，以便今后的回退，有时这是无法做到的。


<http://www.cnblogs.com/balingybj/p/4782032.html> 
