
##[原文](https://my.oschina.net/suemi/blog/852542)

# 异常的处理机制

## 异常的处理机制
上一节大致介绍了[异常是如何产生并捕获的](03、异常的处理机制.md)，
接下来我们详细讲讲athrow指令抛出异常后的故事，也就是如何处理异常的问题。

athrow指令，这个指令运作过程大致是首先检查操作栈顶，
这时栈顶必须存在一个reference类型的值，并且是java.lang.Throwable的子类（虚拟机规范中要求如果遇到null则当作NPE异常使用），
然后暂时先把这个引用出栈，接着搜索本方法的异常表，找一下本方法中是否有能处理这个异常的handler，
如果能找到合适的handler就会重新初始化PC寄存器指针指向此异常handler的第一个指令的偏移地址。

接着把当前栈帧的操作栈清空，再把刚刚出栈的引用重新入栈。如果在当前方法中很悲剧的找不到handler，
那只好把当前方法的栈帧出栈（这个栈是VM栈，不要和前面的操作栈搞混了，栈帧出栈就意味着当前方法退出），
这个方法的调用者的栈帧就自然在这条线程VM栈的栈顶了，
然后再对这个新的当前方法再做一次刚才做过的异常handler搜索，
如果还是找不到，继续把这个栈帧踢掉，这样一直到找，要么找到一个能使用的handler，
转到这个handler的第一条指令开始继续执行，要么把VM栈的栈帧抛光了都没有找到期望的handler，
这样的话这条线程就只好被迫终止、退出了。

对于Java语言中的关键字catch和finally，虚拟机中并没有特殊的字节码指令去支持它们，
都是通过编译器生成字节码片段以及不同的异常处理器来实现。

我们总结一下athrow指令中虚拟机可能做的事情：

1. 检查栈顶异常对象类型（只检查是不是null，是否referance类型，是否Throwable的子类一般在类验证阶段的数据流分析中做，或者索性不做靠编译器保证了，编译时写到Code属性的StackMapTable中，在加载时仅做类型验证）

2. 把异常对象的引用出栈

3. 搜索异常表，找到匹配的异常handler

4. 重置PC寄存器状态

5. 清理操作栈

6. 把异常对象的引用入栈

7. 把异常方法的栈帧逐个出栈（这里的栈是VM栈）

8. 残忍地终止掉当前线程。

## 异常到底慢不慢

这里直接给出一些结论吧：

新建一个异常对象比新建一个普通对象在耗时上多一个数量级，
抛出并捕获异常的耗时比新建一个异常在耗时上也要多一个数量级。
创建一个异常对象却是要比一个普通对象耗时多，捕获一个异常耗时更甚。
捕获的过程我们上面已经简要介绍了，为什么新建一个异常对象这么耗时？且看源码：

在java中，所有的异常都继承自Throwable类，Throwable的构造函数
```java

public Throwable() {
    ...
    fillInStackTrace();
    ...
}

```
有个nativ方法public synchronized native Throwable fillInStackTrace();
这个方法会存入当前线程的堆栈信息。
也就是说每次创建一个异常实例都会把堆栈信息存一遍。这就是时间开销的主要来源了。

这个时候我们可以下一个结论：新建异常对象比创建一个普通对象是要更加的耗时。

- 能避开创建异常的这个耗时吗？   
答案是可以的，如果在程序中我们不关心异常抛出的异常占信息，
我们可以自己定义一个异常继承自已有的异常类型，
并写一个方法覆盖掉fillInStackTrace方法就行了。