
## [原文1](https://blog.csdn.net/xiaochunyong/article/details/7748713)

 


# Java的位运算符详解实例

java提供的位运算符有：左移( << )、右移( >> ) 、无符号右移( >>> ) 、位与( & ) 、位或( | )、位非( ~ )、位异或( ^ )，
除了位非( ~ )是一元操作符外，其它的都是二元操作符。

> 假设有一 int 类型的数，值为5，那么，
我们知道它在计算机中表示为：00000000 00000000 00000000 00000101
> 5转换成二制是101，不过int类型的数占用4字节（32位），所以前面填了一堆0

## 左移( << )

```java

 
public class Test {
	public static void main(String[] args) {
		System.out.println(5<<2);//运行结果是20
	}
}
```

运行结果是20，但是程序是怎样执行的呢？
首先会将5转为2进制表示形式(java中，整数默认就是int类型,也就是32位):

0000 0000 0000 0000 0000 0000 0000 0101           然后左移2位后，低位补0：

0000 0000 0000 0000 0000 0000 0001 0100           换算成10进制为20

> 左移运算符，num << 1,相当于num乘以2
 
## 右移( >> ) ，右移同理，只是方向不一样罢了(感觉和没说一样)

```java
 //运行结果是1
  System.out.println(5>>2);
```
还是先将5转为2进制表示形式：

0000 0000 0000 0000 0000 0000 0000 0101 然后右移2位，高位补0：

0000 0000 0000 0000 0000 0000 0000 0001

> 右移运算符，num >> 1,相当于num除以2

## 3、无符号右移( >>> )

无符号右移>>> ：不管正负标志位为0还是1，将该数的二进制码整体右移，左边部分总是以0填充，右边部分舍弃。

举例对比：

-5>>2: 1111 1011-------------->1111 1110。

11为标志位

-5>>>2:  1111 1011-------------->0011 1110。

00为补充的0

我们知道在Java中int类型占32位，可以表示一个正数，也可以表示一个负数。
正数换算成二进制后的最高位为0，负数的二进制最高为为1

- [参考 负数的二进制表示](负数的二进制表示.md)

例如  -5换算成二进制后为：
```java
 System.out.println(Integer.toBinaryString(-5));
```

1111 1111 1111 1111 1111 1111 1111 1011   
(刚开始接触二进制时，不知道最高位是用来表示正负之分的，当时就总想不通。
明明算起来得到的就是一个正数-_-)


我们分别对5进行右移3位、 -5进行右移3位和无符号右移3位：
```java
        //结果是0
        System.out.println(5>>3);

        //结果是-1
        System.out.println(-5>>3);

        //结果是536870911
        System.out.println(-5>>>3);
``` 

我们来看看它的移位过程(可以通过其结果换算成二进制进行对比)：

5换算成二进制： 0000 0000 0000 0000 0000 0000 0000 0101

 // (用0进行补位)
5右移3位后结果为0，0的二进制为： 0000 0000 0000 0000 0000 0000 0000 0000       

 -5换算成二进制： 1111 1111 1111 1111 1111 1111 1111 1011

// (用1进行补位)
-5右移3位后结果为-1，-1的二进制为： 1111 1111 1111 1111 1111 1111 1111 1111   

// (用0进行补位)
-5无符号右移3位后的结果 536870911 换算成二进制： 0001 1111 1111 1111 1111 1111 1111 1111   


通过其结果转换成二进制后，我们可以发现，正数右移，高位用0补，负数右移，高位用1补，
当负数使用无符号右移时，用0进行部位(自然而然的，就由负数变成了正数了)

注意：笔者在这里说的是右移，高位补位的情况。
正数或者负数左移，低位都是用0补。(自行测试)

## 4、位与( & )

 ```java
 //结果为1
System.out.println(5 & 3);
```

还是老套路，将2个操作数和结果都转换为二进制进行比较：

5转换为二进制：0000 0000 0000 0000 0000 0000 0000 0101

3转换为二进制：0000 0000 0000 0000 0000 0000 0000 0011

-------------------------------------------------------

1转换为二进制：0000 0000 0000 0000 0000 0000 0000 0001


位与：第一个操作数的的第n位于第二个操作数的第n位如果都是1，那么结果的第n为也为1，否则为0


## 5、位或( | )
 
```java
System.out.println(5 | 3);//结果为7

```

5转换为二进制：0000 0000 0000 0000 0000 0000 0000 0101

3转换为二进制：0000 0000 0000 0000 0000 0000 0000 0011

 ---------------------------------------------


7转换为二进制：0000 0000 0000 0000 0000 0000 0000 0111

位或操作：第一个操作数的的第n位于第二个操作数的第n位 只要有一个是1，那么结果的第n为也为1，否则为0



## 6、位异或( ^ )

```java
//结果为6
System.out.println(5 ^ 3);

```

 5转换为二进制：0000 0000 0000 0000 0000 0000 0000 0101
 
 3转换为二进制：0000 0000 0000 0000 0000 0000 0000 0011
 
 ---------------------------------------
 
 
 6转换为二进制：0000 0000 0000 0000 0000 0000 0000 0110
 
 位异或：第一个操作数的的第n位于第二个操作数的第n位 相反，那么结果的第n为也为1，否则为0
 
 

## 7、位非( ~ )  位非是一元操作符

```java
System.out.println(~5);//结果为-6

```

 5转换为二进制：0000 0000 0000 0000 0000 0000 0000 0101
-----------------------------------------

-6转换为二进制：1111 1111 1111 1111 1111 1111 1111 1010

6的32位二进制数为： 0000 0000 0000 0000 0000 0000 0000 0110 

6的32位二进制反向为： 1111 1111 1111 1111 1111 1111 1111 1001 

将反向+1得到

-6的32位二进制数：1111 1111 1111 1111 1111 1111 1111 1010


因为负数在计算机中是以补码形式存在的，比如你要对-5进行位非操作，
需要先将-5的二进制形式做一次反码操作（注意这里第一个符号位不要取反），
负数的补码=反码+1，得到反码后+1就获得了负数的补码，
最后对这个补码的每一位（包括第一个符号位）进行取反操作就得到负数的位非结果

## 位非：操作数的第n位为1，那么结果的第n位为0，反之。


由位运算操作符衍生而来的有：

&= 按位与赋值

|=  按位或赋值

^=  异或赋值

\>>= 右移赋值

\>>>= 无符号右移赋值

<<= 赋值左移



和 += 一个概念而已。



举个例子：
 ```java
        int a = 5
		a &= 3;
		System.out.println(a);//结果是1
```

 
 